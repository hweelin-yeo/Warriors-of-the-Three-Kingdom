open State
open PlayerState
open RecruitPile

(**
 * returns: [find_card card_lst highest_card f] returns the highest or lowest
 * power card in [card_lst], and you can make [f] be (<) to find the lowest card
 * or (>) to find the highest card.
 * requires:
 *  - [card_lst] is a card list
 *  - [highest_card] is a card
 *  - [f] must be either (<) or (>)
*)
let rec find_card card_lst highest_card f =
  match card_lst with
  | [] -> highest_card
  | h :: t -> (
      if f h.power highest_card.power
      then find_card t h f
      else find_card t highest_card f
    )

(**
 * returns: [find_index elem lst lst_size cur_idx] returns the index of [elem]
 * in [lst] when the head of the [lst] has index 0 while the "end" of the [lst]
 * has index (List.length lst) - 1.
 * requires:
 *  - [lst] is a' * b' list
 *  - [elem] is value of type a' * b'
 *  - [lst_size] is an int (must be the size of the [lst])
 *  - [cur_idx] is an int
*)
let rec find_index elem lst lst_size cur_idx =
 match lst with
 | [] -> lst_size - 1
 | h :: t ->
   if (fst h = fst elem) then cur_idx
   else find_index elem t lst_size (cur_idx + 1)

(* [filter_enough_resources s] returns a list of cards that the current
 *  player can actually draw (due to restriction of player resource).
 * requires: s is a cardID list *)
let filter_enough_resources s =
  let current_player_state = List.assoc s.current_player s.player_states in
  List.filter (fun x -> x.cost <= current_player_state.player_resource) s.available_picks

(* [rank_lst_easy_ai s] creates a list of (power, cardID) tuples from
    s, a list of cardIDs.
 * requires: s is a cardID list *)
let rank_lst_easy_ai s =
  List.map (fun x -> (x.power, x)) s

(* [find_rank st id] returns the rank of the current player of
   player_id [id]. [id] is an int. *)
let find_rank st id =
  let player_lst = List.map (fun (x, y) -> (y.player_score, x)) st.player_states in
  let ranked_lst = List.rev (List.sort compare player_lst) in
  let ranked_lst_rev = List.map (fun (x, y) -> (y, x)) ranked_lst in (* (player_id * score)*)
  find_index (id, 0) ranked_lst_rev (List.length ranked_lst_rev) 1

(* [find_diff st id] returns the difference between the score of the
   current player of player_id [id] and the player ranked below him *)
let find_diff st id =
  let player_lst = List.map (fun (x, y) -> (y.player_score, x)) st.player_states in (* (score * player_id)*)
  let ranked_lst = List.rev (List.sort compare player_lst) in
  let ranked_lst_rev = List.map (fun (x, y) -> (y, x)) ranked_lst in (* (player_id * score)*)
  let id_idx = find_index (id, 0) ranked_lst_rev (List.length ranked_lst_rev) 1 in
  try (List.assoc ranked_lst_rev id) - fst (List.nth player_lst (id_idx + 1)) with
  Failure _ -> 0

(* [run_game_sim c st] returns a new state with card drawn as c *)
let run_indiv_sim c st = c |> draw_card st

(* [rank_lst_med_ai st rank_accum diff_accum lst] returns a association list of
   tuples: ((rank, diff), cardID)
   where rank = rank of current player after choosing a card (element in lst)
   and diff = between his score and the player ranked below him.

 * requires: [lst] to be of type card list
             [st] to be of type state
             [rank_accum] to be a tuple list,
             where typle is described as
             above.*)
let rec rank_lst_med_ai st accum lst=
  match lst with
  | [] -> accum
  | h :: t -> let new_st = run_indiv_sim h st in
    let rank = find_rank new_st st.current_player in
    let diff = find_diff new_st st.current_player in
    rank_lst_med_ai t st (((rank, diff), x) :: accum)

(* [med_sort_compare lst] returns a sorted list of tuple generated by
 * rank_lst_med_ai.
 * requires: lst to be a list of ((rank, diff), cardID). *)
let med_sort_compare lst =
  let lst' = List.map (fun ((r,d), id) -> ((1/r, d), id)) lst in
  List.sort compare lst'

let easy_ai_next_move s =
  try
    Some (s |> filter_enough_resources |> rank_lst_easy_ai s
    |> List.sort compare |> List.rev |> List.hd |> snd)
  with Failure _ -> None

let medium_ai_next_move s =
  try
    Some (s |> filter_enough_resources |> rank_lst_med_ai s []
    |> med_sort_compare |> List.rev |> List.hd |> snd)
  with Failure _ -> None
