open State
open PlayerState

(**
 * returns: [find_card card_lst highest_card f] returns the highest or lowest
 * power card in [card_lst], and you can make [f] be (<) to find the lowest card
 * or (>) to find the highest card.
 * requires:
 *  - [card_lst] is a card list
 *  - [highest_card] is a card
 *  - [f] must be either (<) or (>)
*)
let rec find_card card_lst highest_card f =
  match card_lst with
  | [] -> highest_card
  | h :: t -> (
      if f h.power highest_card.power
      then find_card t h f
      else find_card t highest_card f
    )

(**
 * returns: [find_index elem lst lst_size cur_idx] returns the index of [elem]
 * in [lst] when the head of the [lst] has index 0 while the "end" of the [lst]
 * has index (List.length lst) - 1.
 * requires:
 *  - [lst] is a' * b' list
 *  - [elem] is value of type a' * b'
 *  - [lst_size] is an int (must be the size of the [lst])
 *  - [cur_idx] is an int
*)
let rec find_index elem lst lst_size cur_idx =
 match lst with
 | [] -> lst_size - 1
 | h :: t ->
   if (fst h = fst elem) then cur_idx
   else find_index elem t lst_size (cur_idx + 1)

(* [filter_enough_resources s] returns a list of card ID's that the current
 *  player can actually draw (due to restriction of player resource).
 * requires: s is a cardID list *)
let filter_enough_resources s =
  let current_player_state = List.assoc s.current_player s.player_states in
  let card_lst = id_to_card_lst s s.available_picks in
  let card' = List.filter
      (fun x -> x.cost <= current_player_state.player_resource) card_lst in
  List.map (fun x -> x.card_id) card'

(* [pick_rand_cardID cardID_lst] returns a random cardID in [cardID_lst].
 * requires: s is a cardID list *)
let pick_rand_cardID cardID_lst =
  let length = List.length cardID_lst in
  List.nth cardID_lst (Random.int length)

(* [rank_lst_med_ai s] creates a list of (power, cardID) tuples from
    s, a list of cardIDs.
 * requires: s is a cardID list *)
let rank_lst_med_ai st cardlst =
  List.map (fun x -> (List.hd (id_to_card_lst st [x])).power, x) cardlst

(* [find_rank st id] returns the rank of the current player of
   player_id [id]. [id] is an int. *)
let find_rank st id =
  let player_lst = List.map (fun (x, y) -> (y.player_score, x)) st.player_states in
  let ranked_lst = List.rev (List.sort compare player_lst) in
  let ranked_lst_rev = List.map (fun (x, y) -> (y, x)) ranked_lst in (* (player_id * score)*)
  find_index (id, 0) ranked_lst_rev (List.length ranked_lst_rev) 1

(* [find_diff st id] returns the difference between the score of the
   current player of player_id [id] and the player ranked below him *)
let find_diff st id =
  let player_lst = List.map (fun (x, y) -> (y.player_score, x)) st.player_states in (* (score * player_id)*)
  let ranked_lst = List.rev (List.sort compare player_lst) in
  let ranked_lst_rev = List.map (fun (x, y) -> (y, x)) ranked_lst in (* (player_id * score)*)
  let id_idx = find_index (id, 0) ranked_lst_rev (List.length ranked_lst_rev) 1 in
  try (List.assoc id ranked_lst_rev) - fst (List.nth player_lst (id_idx + 1)) with
  Failure _ -> 0

(* [run_game_sim c st] returns a new state with card drawn as c *)
let run_indiv_sim c st = draw_card c st

(* [rank_lst_hard_ai st rank_accum diff_accum lst] returns a association list of
   tuples: ((rank, diff), cardID)
   where rank = rank of current player after choosing a card (element in lst)
   and diff = between his score and the player ranked below him.

 * requires: [lst] to be of type card list
             [st] to be of type state
             [rank_accum] to be a tuple list,
             where typle is described as
             above.*)
let rec rank_lst_hard_ai (st: state) (accum: ((int * int) * cardID) list) (lst: cardID list) =
  match lst with
  | [] -> accum
  | h :: t ->
    let new_st = run_indiv_sim h st in
    (* let rank = find_rank new_st st.current_player in *)
    (* let diff = find_diff new_st st.current_player in *)
    let rank = find_rank new_st st.current_player in
    let diff = find_diff new_st st.current_player in
    rank_lst_hard_ai st (((rank, diff), h) :: accum) t

(* [hard_sort_compare lst] returns a sorted list of tuple generated by
 * rank_lst_med_ai.
 * requires: lst to be a list of ((rank, diff), cardID). *)
let hard_sort_compare lst =
  let lst' = List.map (fun ((r,d), id) -> ((1/r, d), id)) lst in
  List.sort compare lst'

(*Precondition: s is a valid list of inputs*)
(*Postcondition: returns a random unit from the list of inputs*)
let easy_ai_next_move s =
  try
    Some (s |> filter_enough_resources |> pick_rand_cardID)
  with Failure _ -> None

(*Precondition: s is a valid list of inputs*)
(*Postcondition: returns the move given a set of states such that
  the ai will try to put itself in first palce, then try to minimize the
  difference between first place and itself*)
let medium_ai_next_move s =
  try
    Some (s |> filter_enough_resources |> rank_lst_med_ai s
          |> List.sort compare |> List.rev |> List.hd |> snd)
  with Failure _ -> None

(*Precondition: s is a list of possible moves *)
(*Postcondition: picks a move from the list of valid moves that will maximize the
  player's score with a priority towards moving the player to first place*)
let hard_ai_next_move s =
  try
    Some (s |> filter_enough_resources |> (rank_lst_hard_ai s [])
    |> hard_sort_compare |> List.rev |> List.hd |> snd)
  with Failure _ -> None
